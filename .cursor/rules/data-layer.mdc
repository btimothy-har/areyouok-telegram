---
globs: src/areyouok_telegram/data/**
alwaysApply: false
---
# Data Layer Conventions

Conventions and patterns for the data layer (`src/areyouok_telegram/data/`).

## Database Connection

### Context Manager Pattern

Always use the async context manager for database operations:

```python
from areyouok_telegram.data.database import async_database

async with async_database() as db_conn:
    # db_conn is an AsyncSession
    result = await db_conn.execute(stmt)
    # Commit happens automatically on success
    # Rollback happens automatically on exception
    # Connection closes automatically
```

**The context manager handles:**
- Session creation
- Automatic commit on success
- Automatic rollback on exception
- Session cleanup

### Never Manually Commit/Rollback

❌ **Don't do this:**
```python
async with async_database() as db_conn:
    result = await db_conn.execute(stmt)
    await db_conn.commit()  # NO! Context manager does this
```

✅ **Do this:**
```python
async with async_database() as db_conn:
    result = await db_conn.execute(stmt)
    # Done! Context manager handles commit
```

## Data Model Conventions

### Standard Access Pattern

All models follow a consistent ID-first access pattern optimized for future caching:

1. **`get_by_id` accepts only internal IDs** - Single-purpose method for ID-based retrieval
2. **`save()` returns via `get_by_id`** - Consistent hydration path
3. **Query methods use ID-first pattern** - Query for IDs, then hydrate via `get_by_id`

This creates a single retrieval bottleneck where caching can be added later.

### get_by_id Pattern

**All models must implement `get_by_id` accepting only the internal ID:**

✅ **Standard Pattern:**
```python
@classmethod
@db_retry()
async def get_by_id(cls, *, user_id: int) -> User | None:
    """Retrieve a user by internal ID.
    
    Args:
        user_id: Internal user ID
        
    Returns:
        User instance if found, None otherwise
    """
    async with async_database() as db_conn:
        stmt = select(UsersTable).where(UsersTable.id == user_id)
        result = await db_conn.execute(stmt)
        row = result.scalars().first()
        
        if row is None:
            return None
            
        return cls.model_validate(row, from_attributes=True)
```

**For models needing Chat for decryption:**
```python
@classmethod
@db_retry()
async def get_by_id(cls, chat: Chat, *, message_id: int) -> Message | None:
    """Retrieve a message by internal ID, auto-decrypted."""
    # Chat is needed for decryption, passed as first parameter
    ...
```

### Alternative Lookup Methods

Models with multiple lookup paths provide separate methods:

```python
# Internal ID lookup (standard)
await User.get_by_id(user_id=123)

# Telegram ID lookup (helper)
await User.get_by_telegram_id(telegram_user_id=456)

# By name lookup (helper)
await JobState.get(job_name="my_job")
```

❌ **Don't combine lookups in get_by_id:**
```python
# BAD - Don't do this
async def get_by_id(cls, *, user_id: int | None = None, telegram_id: int | None = None):
    ...
```

### save() Pattern

All `save()` methods must return via `get_by_id` for consistent hydration:

```python
@db_retry()
async def save(self) -> User:
    """Save or update the user in the database.
    
    Returns:
        User instance refreshed from database
    """
    async with async_database() as db_conn:
        stmt = (
            pg_insert(UsersTable)
            .values(...)
            .returning(UsersTable)
        )
        
        result = await db_conn.execute(stmt)
        row = result.scalar_one()
    
    # Return via get_by_id (not reconstructing from row)
    return await User.get_by_id(user_id=row.id)
```

### ID-First Query Pattern

All list/search methods must query for IDs first, then hydrate via `get_by_id` **concurrently using asyncio.gather**:

```python
import asyncio

@classmethod
@db_retry()
async def get_by_session(cls, chat: Chat, *, session_id: int) -> list[Message]:
    """Retrieve messages by session_id, auto-decrypted."""
    # Step 1: Query for IDs only
    async with async_database() as db_conn:
        stmt = (
            select(MessagesTable.id)  # Select only ID
            .where(MessagesTable.session_id == session_id)
            .where(MessagesTable.chat_id == chat.id)
            .order_by(MessagesTable.created_at)
        )
        
        result = await db_conn.execute(stmt)
        message_ids = result.scalars().all()
    
    # Step 2: Hydrate via get_by_id concurrently
    message_tasks = [cls.get_by_id(chat, message_id=msg_id) for msg_id in message_ids]
    messages_with_none = await asyncio.gather(*message_tasks)
    messages = [msg for msg in messages_with_none if msg is not None]
    
    return messages
```

**Benefits:**
- Single retrieval point for all object hydration
- Easy to add caching layer to `get_by_id` later
- Consistent decryption/validation logic
- Easier testing and debugging
- **Concurrent fetching for better performance**

### Method Signature Pattern

All other arguments MUST be keyword-only (except Chat when needed for decryption):

✅ **Correct:**
```python
@classmethod
async def get_by_id(cls, *, user_id: int) -> User | None:
    pass

# Or with Chat for decryption
@classmethod
async def get_by_id(cls, chat: Chat, *, message_id: int) -> Message | None:
    pass
```

❌ **Incorrect:**
```python
@classmethod
async def get_by_id(cls, user_id: int) -> User | None:  # Missing *
    pass
```

### Standard Decorators

Apply decorators in this order:

```python
@classmethod  # If it's a class method
@traced(extract_args=["arg1", "arg2"])  # Or extract_args=False for sensitive data
@db_retry()  # Always apply for database operations
async def method_name(cls, db_conn: AsyncSession, *, ...):
    pass
```

**Decorator Guidelines:**
- `@traced()`: Use for observability
  - `extract_args=False`: For methods handling sensitive data
  - `extract_args=["field1", "field2"]`: To log specific safe arguments
- `@db_retry()`: Always use for database operations (handles transient failures)

### Model Structure

All models should follow this pattern:

```python
class MyModel(pydantic.BaseModel):
    """Model description."""
    
    model_config = pydantic.ConfigDict(arbitrary_types_allowed=True)
    
    # Required fields (no defaults)
    chat: Chat
    user_id: int
    
    # Optional fields (with defaults)
    id: int = 0
    created_at: datetime = pydantic.Field(default_factory=lambda: datetime.now(UTC))
    
    @property
    def object_key(self) -> str:
        """Unique identifier for deduplication."""
        return hashlib.sha256(f"model:{self.id}:{...}".encode()).hexdigest()
```

## Data Model Organization

Models are organized by domain:

### `messaging/`
- **Chat**: Telegram chat/conversation
- **Message**: User and bot messages
- **Session**: Conversation sessions
- **Context**: Session context and metadata
- **MediaFile**: Audio, images, documents
- **GuidedSession**: Structured conversation flows
- **ChatEvent**: Chat lifecycle events

### `users/`
- **User**: Telegram user profile
- **UserMetadata**: Extended user information

### `system/`
- **Update**: Telegram update tracking
- **JobState**: Background job state
- **Notification**: System notifications
- **CommandUsage**: Command analytics

### `llm/`
- **LLMUsage**: Token usage tracking
- **LLMGeneration**: LLM request/response logs

## Encryption Patterns

### Per-Chat Encryption

All sensitive user data (messages, context) MUST be encrypted using per-chat Fernet keys.

**Encryption Flow:**
```python
class Message(pydantic.BaseModel):
    chat: Chat
    payload: dict
    
    def encrypt_message(self) -> str:
        """Encrypt payload using chat's key."""
        user_encryption_key = self.chat.retrieve_key()
        fernet = Fernet(user_encryption_key.encode())
        payload_json = json.dumps(self.payload)
        encrypted_bytes = fernet.encrypt(payload_json.encode("utf-8"))
        return encrypted_bytes.decode("utf-8")
```

**Decryption Flow:**
```python
@staticmethod
def decrypt_message(encrypted_payload: str, user_encryption_key: str) -> dict:
    """Decrypt payload."""
    fernet = Fernet(user_encryption_key.encode())
    encrypted_bytes = encrypted_payload.encode("utf-8")
    decrypted_bytes = fernet.decrypt(encrypted_bytes)
    return json.loads(decrypted_bytes.decode("utf-8"))
```

### Save Pattern

Models should:
1. Encrypt sensitive data before saving
2. Return via `get_by_id` for consistent hydration

```python
@traced(extract_args=False)  # Sensitive data
@db_retry()
async def save(self) -> Message:
    """Save message with encryption."""
    encrypted_payload = self.encrypt_message()
    
    async with async_database() as db_conn:
        stmt = (
            pg_insert(MessagesTable)
            .values(
                object_key=self.object_key,
                encrypted_payload=encrypted_payload,
                # ... other fields
            )
            .returning(MessagesTable)
        )
        
        result = await db_conn.execute(stmt)
        row = result.scalar_one()
        
    # Return via get_by_id for consistent hydration
    return await Message.get_by_id(self.chat, message_id=row.id)
```

### Retrieval Pattern

Always decrypt after retrieval via `get_by_id`:

```python
@classmethod
@db_retry()
async def get_by_id(cls, chat: Chat, *, message_id: int) -> Message | None:
    """Retrieve and decrypt message."""
    async with async_database() as db_conn:
        stmt = select(MessagesTable).where(MessagesTable.id == message_id)
        result = await db_conn.execute(stmt)
        row = result.scalars().first()
        
        if row is None:
            return None
        
        # Decrypt before returning
        encryption_key = chat.retrieve_key()
        decrypted_payload = cls.decrypt_message(row.encrypted_payload, encryption_key)
        
        return Message(
            id=row.id,
            chat=chat,
            payload=decrypted_payload,
            # ... other fields
        )
```

## Query Patterns

### Use PostgreSQL INSERT...ON CONFLICT

For upsert operations, use PostgreSQL's native conflict handling:

```python
from sqlalchemy.dialects.postgresql import insert as pg_insert

stmt = (
    pg_insert(TableName)
    .values(
        object_key=unique_key,
        field1=value1,
        # ...
    )
    .on_conflict_do_nothing(index_elements=["object_key"])
    .returning(TableName)
)
```

### Filtering with Optional Parameters

All list/filter methods use the ID-first pattern with concurrent hydration:

```python
import asyncio

@classmethod
@db_retry()
async def get_by_chat(
    cls,
    chat: Chat,
    *,
    from_timestamp: datetime | None = None,
    to_timestamp: datetime | None = None,
) -> list[Message]:
    """Retrieve messages with optional filtering."""
    # Step 1: Query for IDs only
    async with async_database() as db_conn:
        stmt = select(MessagesTable.id).where(MessagesTable.chat_id == chat.id)
    
    # Apply optional filters
    if from_timestamp:
        stmt = stmt.where(MessagesTable.created_at >= from_timestamp)
    
    if to_timestamp:
        stmt = stmt.where(MessagesTable.created_at < to_timestamp)
    
    stmt = stmt.order_by(MessagesTable.created_at.desc())
    
    result = await db_conn.execute(stmt)
        message_ids = result.scalars().all()
    
    # Step 2: Hydrate via get_by_id concurrently
    message_tasks = [cls.get_by_id(chat, message_id=msg_id) for msg_id in message_ids]
    messages_with_none = await asyncio.gather(*message_tasks)
    messages = [msg for msg in messages_with_none if msg is not None]
    
    return messages
```

## Common Patterns

### Object Keys for Deduplication

Use SHA-256 hashes of identifying fields:

```python
@property
def object_key(self) -> str:
    """Unique key for deduplication."""
    unique_string = f"model:{self.field1}:{self.field2}:{self.field3}"
    return hashlib.sha256(unique_string.encode()).hexdigest()
```

### Timestamps

Always use UTC:

```python
from datetime import UTC, datetime

created_at: datetime = pydantic.Field(default_factory=lambda: datetime.now(UTC))
```

### Return None for Not Found

Prefer returning `None` over raising exceptions for not-found cases:

```python
async def get_by_id(cls, db_conn: AsyncSession, *, record_id: int) -> Record | None:
    """Returns None if not found."""
    result = await db_conn.execute(stmt)
    row = result.scalars().first()
    
    if row is None:
        return None  # Not raising an exception
    
    return Record(...)
```

### Raise Exceptions for Invalid Input

Raise descriptive exceptions for invalid arguments:

```python
class InvalidMessageTypeError(Exception):
    def __init__(self, message_type: str):
        super().__init__(f"Invalid message type: {message_type}. Expected 'Message' or 'MessageReactionUpdated'.")
        self.message_type = message_type
```

## Privacy & Security Rules

### Never Log Sensitive Data

❌ **Never:**
- Message content
- Encryption keys
- User tokens
- Personal information

✅ **Safe to log:**
- Record IDs
- Counts/statistics
- Timestamps
- Operation outcomes

### Use extract_args=False

For methods handling sensitive data:

```python
@traced(extract_args=False)  # Don't log any arguments
@db_retry()
async def save_message(self, db_conn: AsyncSession, *, content: str):
    pass
```

### Encryption Key Storage

- Per-chat keys derived from chat ID + application salt
- Keys retrieved via `chat.retrieve_key()`
- Never store decrypted keys in database
- Never log encryption keys
